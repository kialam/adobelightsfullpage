<!doctype html>
<html lang="en">
	<head>
		<title>adobe</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #232323;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}

			a { color: skyblue }
		</style>
	</head>
	<body>
		
		<input type="file" id="input" name="files[]" multiple style="position: absolute;display:none;"/>
		<canvas id="canvasUpload" width="1024" height="1024" style="display:none;"></canvas>

		<div style="position:absolute; visibility:hidden;"><canvas id="canvasOutput" width="100" height="100"></canvas></div>
			<div id="image-wrapper"></div>
		<div id="viewport"></div>



		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script type="text/javascript" src="js/reconnecting-ws.min.js"></script>
		<script type="text/javascript" src="js/Client.js?v=1"></script>
		<script type="text/javascript" src="js/main.js?v=1"></script>

		<script src="js/three.min.js"></script>

		<script src="js/loaders/ColladaLoader.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
		
		<script src="js/Detector.js"></script>
		<script src="js/Stats.js"></script>


		<script>
		 	var input = document.getElementById('input');
			input.addEventListener('change', handleFiles);

			function handleFiles(e) {
			    var ctx = document.getElementById('canvasUpload').getContext('2d');
			    var img = new Image;
			    img.src = URL.createObjectURL(e.target.files[0]);
			    img.onload = function() {
		            //ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
		            ctx.clearRect( 0, 0, 1024, 1024 )
			        ctx.drawImage(img,0,0, 1024, 1024);
			        //alert('the image is drawn');

			        var newTexture = new THREE.Texture(document.getElementById("canvasUpload"));
						newTexture.needsUpdate = true;
						if(planeMaterial)planeMaterial.map = newTexture;
			    }
			}
		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var planeMaterial;

			var camera, scene, renderer, objects;
			var directionalLight, pointLight;
			var dae, mouse;
			var texture;
			var plane;

			var water;
			var waterNormals;
			var mirrorMesh;
			var lights;
			var canvas = document.getElementById('canvasOutput');

			var last_selected_block;

			init();
			build();
			animate();

			function build(){
				texture=THREE.ImageUtils.loadTexture('test.png')
				//texture.needsUpdate = true;
				texture.magFilter = THREE.NearestFilter;
				texture.minFilter = THREE.LinearMipMapLinearFilter;
				var material = new THREE.MeshBasicMaterial({
			    	map: texture,transparent:true
			    });

				texture = new THREE.Texture(canvas);
				texture.needsUpdate = true;
				texture.magFilter = THREE.NearestFilter;
				texture.minFilter = THREE.LinearMipMapLinearFilter;

				var materialG = new THREE.MeshBasicMaterial({
			    	map: /*THREE.ImageUtils.loadTexture('grid.png')*/texture, ambient: 0xffffff/*, blending: THREE.AdditiveBlending*/
			    });
				var materialG2 = new THREE.MeshBasicMaterial({
			    	map: /*THREE.ImageUtils.loadTexture('grid.png')*/texture, ambient: 0xffffff/*, blending: THREE.AdditiveBlending*/
			    });

				var materialT = new THREE.MeshLambertMaterial({
			    	color: 0xffffff, opacity: 0.2, transparent: true
			    });

				var shellGeometry = new THREE.Geometry();
				var lightsGeometry = new THREE.Geometry();
				lights = new THREE.Mesh();
				var lightsReflectionGeometry = new THREE.Geometry();

				function addShort(_x,_y){
					var side = new THREE.Mesh(
						new THREE.CubeGeometry( 1, 1, 10 ),
						material
					);

					side.position.x=(-5+_x)*10;
					side.rotation.z=Math.PI/2;
					side.position.y=(-5+_y)*10;
					//scene.add(side);
					THREE.GeometryUtils.merge(shellGeometry, side);
				}
				function addLong(vertical, position,_z){
					if(!vertical){
						var side = new THREE.Mesh(
							new THREE.CubeGeometry( 1, 100, 1 ),
							material
						);
					}else{
						var side = new THREE.Mesh(
							new THREE.CubeGeometry( 1, 200, 1 ),
							material
						);
					}
					var _x=position;
					var _y=5;
					if(!vertical){
						_x=5;
						_y=position;
						side.rotation.z=Math.PI/2;
					}
					if(vertical)_y-=5;

					side.position.x=(-5+_x)*10;
					side.position.y=(-5+_y)*10;
					side.position.z = _z
					//scene.add(side);
					THREE.GeometryUtils.merge(shellGeometry, side);
				}
				for (var _x = 0; _x < 11; _x++) {
					for (var _y = -10; _y < 11; _y++) {
						addShort(_x,_y);
					}
				};
				for (var _x = 0; _x < 11; _x++) {
					addLong(true,_x,5);
					addLong(true,_x,-5);
				};
				for (var _y = -10; _y < 11; _y++) {
					addLong(false,_y,5);
					addLong(false,_y,-5);
				}


				for (var _x = 0; _x < 10; _x++) {
					for (var _y = 0; _y < 10; _y++) {
						var geom = new THREE.CubeGeometry( 10, 10, 10 );
						change_uvs( geom, 1/10, 1/10, _x, _y );
						var front = new THREE.Mesh(
							geom,
							materialG
						);

						var geom2 = new THREE.CubeGeometry( 10, 10, 10 );
						change_uvs( geom2, 1/10, 1/10, _x, _y );
						var front2 = new THREE.Mesh(
							geom2,
							materialG
						);
						front.rotation.x=Math.PI;
						//front.rotation.y=Math.PI;
						front.position.x=(-4.5+_x)*10;
						front.position.y=(-4.5+_y)*10;
						lights.add(front);

						front2.rotation.x=Math.PI;
						//front.rotation.y=Math.PI;
						front2.position.x=(-4.5+_x)*10;
						front2.position.y=(-4.5+_y)*10;
						THREE.GeometryUtils.merge(lightsReflectionGeometry, front2);
					}
				};

				var shell = new THREE.Mesh(shellGeometry,material);
				//var lights = new THREE.Mesh(lightsGeometry,materialG);
				scene.add(lights);
				scene.add(shell);

				var lightsReflection = new THREE.Mesh(lightsReflectionGeometry,materialG);
				lightsReflection.rotation.x=Math.PI;
				lightsReflection.position.y=-100;
				scene.add(lightsReflection);
			
				//ocean();
			}
			

			function ocean(){
				/*waterNormals = new THREE.ImageUtils.loadTexture( 'waternormals.png' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 

				water = new THREE.Water( renderer, camera, scene, {
					textureWidth: 512, 
					textureHeight: 512,
					waterNormals: waterNormals,
					alpha: 	1.0,
					sunDirection: directionalLight.position.normalize(),
					sunColor: 0xffffff,
					waterColor: 0x2d2d2d,
					distortionScale: 50.0,
				} );

				mirrorMesh = new THREE.Mesh(
					new THREE.PlaneGeometry( 1500,1500 , 1, 1 ), 
					water.material
				);
				

				mirrorMesh.add( water );
				mirrorMesh.position.y = -50-1;
				mirrorMesh.rotation.x = Math.PI * 0.5;
				mirrorMesh.rotation.y = Math.PI;
				mirrorMesh.rotation.z = Math.PI;
				scene.add( mirrorMesh );*/
			}

			function change_uvs( geometry, unitx, unity, offsetx, offsety ) {

				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				for ( var i = 0; i < faceVertexUvs.length; i ++ ) {
					var uvs = faceVertexUvs[ i ];
					for ( var j = 0; j < uvs.length; j ++ ) {
						var uv = uvs[ j ];
						uv.x = ( uv.x + offsetx ) * unitx;
						uv.y = ( uv.y + offsety ) * unity;
					}
				}
			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 1, 4000 );
				camera.position.set( 2, 2, 3 );
				scene.add( camera );


				directionalLight = new THREE.DirectionalLight(0xffffff);
				directionalLight.position.set(-1,-1,-1);
			    //directionalLight.castShadow=true;
				//	directionalLight.shadowCameraVisible = true;
				scene.add( directionalLight );
				// Grid

				var line_material = new THREE.LineBasicMaterial( { color: 0x333333 } ),
					geometry = new THREE.Geometry(),
					floor = -0.04, step = 400, size = 20000;

				for ( var i = 0; i <= size / step * 2; i ++ ) {

					geometry.vertices.push( new THREE.Vector3( - size, floor, i * step - size ) );
					geometry.vertices.push( new THREE.Vector3(   size, floor, i * step - size ) );

					geometry.vertices.push( new THREE.Vector3( i * step - size, floor, -size ) );
					geometry.vertices.push( new THREE.Vector3( i * step - size, floor,  size ) );

				}

				var line = new THREE.Line( geometry, line_material, THREE.LinePieces );
				line.position.y = -1.5*40;	
				line.position.x = step/2;
				line.position.z = step/2;
				//scene.add( line );

				 var cube = new THREE.Mesh(new THREE.CubeGeometry(15*20, 5*20, 5*20), new THREE.MeshLambertMaterial({color: 0xcc0000}));
			    cube.position.y = 5*40;
			    cube.rotation.x=30
			    cube.castShadow=true;
			    //scene.add(cube);

			    /*
				planeMaterial = new THREE.MeshBasicMaterial({
			    	color: 0xFFFFFF, opacity:1, transparent:true,map: THREE.ImageUtils.loadTexture('floor.png')
			    });

				plane = new THREE.Mesh(new THREE.PlaneGeometry(40*6,40*6), planeMaterial);
				plane.position.y = -50;	
				plane.rotation.x = -Math.PI/2
				scene.add(plane);
				*/

				var texture=THREE.ImageUtils.loadTexture('lightglow.png')
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				var glowMaterial = new THREE.MeshBasicMaterial({
			    	color: 0xFFFFFF, opacity:1, transparent:true,map: texture
			    });
				glowMaterial.transparent = true;
				glowMaterial.blending = THREE[ "CustomBlending" ];
				glowMaterial.blendSrc = THREE[ "DstColorFactor" ];
				glowMaterial.blendDst = THREE[ "DstAlphaFactor" ];
				var glowGeom = new THREE.PlaneGeometry(100,100);
				change_uvs( glowGeom, 10, 10, 0,0 );
				var glowPlane = new THREE.Mesh(glowGeom, glowMaterial);
				glowPlane.position.z=6;
				scene.add(glowPlane);		



				var texture=THREE.ImageUtils.loadTexture('reflectiongradient.png')
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				var glowMaterial = new THREE.MeshBasicMaterial({
			    	color: 0xFFFFFF, opacity:1, transparent:true,map: texture
			    });
				var glowGeom = new THREE.PlaneGeometry(102,100);
				var glowPlane = new THREE.Mesh(glowGeom, glowMaterial);
				glowPlane.position.z=6;
				glowPlane.position.y=-100
				scene.add(glowPlane);		

				var glowPlane = new THREE.Mesh(glowGeom, glowMaterial);
				glowPlane.scale.x=.12;
				glowPlane.rotation.y=-Math.PI/2;
				glowPlane.position.x=-50.8
				glowPlane.position.y=-100
				//glowPlane.position.z=-5;
				scene.add(glowPlane);		

				var glowPlane = new THREE.Mesh(glowGeom, glowMaterial);
				glowPlane.scale.x=.12;
				glowPlane.rotation.y=Math.PI/2;
				glowPlane.position.x=50.7
				glowPlane.position.y=-100
				//glowPlane.position.z=-5;
				scene.add(glowPlane);		
				

				
				/*pointLight = new THREE.SpotLight( 0xffffff, .9 );
				pointLight.shadowCameraNear = 1;
				pointLight.shadowCameraFar = 5000;
				pointLight.position.y=10
				pointLight.castShadow=true;
				pointLight.shadowCameraVisible = true;
				scene.add( pointLight );*/

				renderer = new THREE.WebGLRenderer({ antialias : true});
				renderer.setClearColor( 0x141414, 1 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.setDepthTest(false);
					//renderer.autoClear = false;
			    //  renderer.shadowCameraNear = 1;
				//renderer.shadowCameraFar = 50;
				//THREEx.WindowResize(renderer, camera);

				container.appendChild( renderer.domElement );

				//stats = new Stats();
				//stats.domElement.style.position = 'absolute';
				//stats.domElement.style.top = '0px';
				//container.appendChild( stats.domElement );

				mouse = new THREE.Vector3( 0, 0, 1 );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', handleMouseDown );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			 function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				//controls.handleResize();

			}

			function handleMouseDown( evt ) {
					var ray, intersections;
					var _vector = new THREE.Vector3;
					var projector = new THREE.Projector();
					
					
					_vector.set(
						( evt.clientX / window.innerWidth ) * 2 - 1,
						-( evt.clientY / window.innerHeight ) * 2 + 1,
						1
					);

					projector.unprojectVector( _vector, camera );
					
					ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
					intersections = ray.intersectObjects( lights.children );

					if ( intersections.length > 0 ) {
						selected_block = intersections[0].object;
						last_selected_block = selected_block;
						console.log(selected_block);

						var minX =50
						var maxX = -50

						var minY = -50
						var maxY = 50

						var pX = intersections[0].point.x;
						var pY = intersections[0].point.y;
						console.log(pX,pY);
						var percX = Math.floor((pX-minX)/(maxX-minX)*10);
						var percY = 9-Math.floor((pY-minY)/(maxY-minY)*10);
						var blockId = percY*10+percX;
						console.log(blockId);
						var box = findPointer();
						parent.$('body').trigger({
							type:'cubeclick',
							artistId: blockId,
							box: box,
							pY : pY,
							pX : pX
						});
						//console.log(percX, percY, percY*10+percX) //arr[percY][percX],
						//console.log('clicked:');
						//console.log(selected_block);
					}
				};

			function onDocumentMouseMove( event ) {

				mouse.x = ( event.clientX / window.innerWidth )*.5 ;
				mouse.y = ( event.clientY / window.innerHeight  )*.5 ;

			}


			function animate() {

				requestAnimationFrame( animate );

				render();
				//stats.update();

			}

			function findPointer(){
				if(!last_selected_block)return;
		            var pos = last_selected_block.position.clone();
		            var projScreenMat = new THREE.Matrix4();
		            projScreenMat.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		            pos.applyProjection(projScreenMat);

		            return { x: ( pos.x + 1 ) * window.innerWidth / 2 ,
		                 y: ( - pos.y + 1) * window.innerHeight / 2 };

			}

			function render() {

				var timer = 3 - mouse.x * 1;//Date.now() * 0.0001;
				var timer2 =  -.2+mouse.y/3;//Date.now() * 0.0001;

				var box = findPointer();
				//console.log(box);
				if(box){
	                parent.$('body').trigger({
	                    type: 'cubemove',
	                    box: box,
	                });
	            }

				if(context){
					var dis = 1;
					var spd = .0005;
					for( var _x = 0; _x < 10; _x++ ) {
						for( var _y = 0; _y < 10; _y++ ) {
							if(false &&_x==0 && _y<=3){
							}else{
								var color = "rgba( " + 
									Math.floor(255*.50+Math.sin( dis+43.1+_y*.123-Date.now()*spd)*255*.37) + ", " + 
									Math.floor(255*.50+Math.cos( dis*3+32.32/(_x+1)*.3+Date.now()*spd*1.12)*255*.37) + ", " + 
									Math.floor(255*.50+Math.sin( dis*2+1.32/_y*_x+Date.now()*spd*1.13)*255*.37) + ", 1)";
								context.fillStyle = color;
								context.fillRect(_x,_y,1,1);
								dis++
							}
						}
					}
				}
				if ( texture ) texture.needsUpdate = true;

				camera.position.x -=(camera.position.x+ Math.cos( timer+2 ) * (3*40*3))/5;
				camera.position.y -=(camera.position.y- (Math.sin( timer+2 ) * (-50+timer2*80*20/10)-70))/5;//= 2*40;// 2;
				camera.position.z =130//-=(camera.position.z- Math.sin( timer+2 ) * (timer2*80*40))/5;

				camera.lookAt( new THREE.Vector3(0,10,0 ) );

				if(water){
					water.material.uniforms.time.value += .1 / 60.0;
					water.render();
				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
